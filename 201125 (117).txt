<201125 자습 과제>​
​
1.키워드란 무엇인가?
 - 자바에서 문법으로 정의한 단어들
​
2.2의 보수법이란?
 - 음의 정수를 2진수로 표현하는 방법
 - 양의 정수에 1의 보수법을 취한 후 + 1 = 2의 보수법
​
3.컴퓨터에서 음의 정수 표현방법에 대하여 설명하시오.
 - 양의 정수에 2의 보수법을 취해 음의 정수로 표현함
 
4.-5가 컴퓨터에서의 2진수 값을 나타내시오.
 - 양의 정수 5 = 00000101
 - 00000101에 1의 보수를 취함 = 11111010
 - 1을 더함 = 11111010 + 1 = 11111011
 - 음의 정수 5 = 11111011​
​
5.실수에서 오차가 생기는 원인은 무엇인가?
 - 실수는 무한한 수인데, 컴퓨터에서 표현하기 위해서는 유한한 메모리에 무한한 수를 넣어야 함. 
   이렇게 하기 위한 방법으로 최소, 최대값 안에서 표현하고자 하는 실수와 가장 근접한 값(근사값)을 해당
   실수라고 하도록 함.
   때문에 표현하고자 하는 실수의 정확한 값 대신 근사값이 표현되어, 연산을 하게 되면 오차가 나타나게 됨.
​
6.실수의 표현법은(고정소수법, 부동소수법)을 설명하시오.
 - 고정소수법 : 소수점이 고정되어 있는 표현법. 정수의 표현 방식에 소수점을 찍어 실수를 표현함
 - 부동소수법 : 소수점이 움직이는 표현법. 부호비트와 가수, 지수로 나눠 실수를 표현하고 저장함. 
                 3.4e3 = 3.4 x 10의 3승이라는 의미
​
7.정밀도란 무엇인가요?
 - 실수를 표현할 때 최대, 최소값의 범위가 커지면 해당 실수의 오차 범위도 커지게 됨.
 - 주의할 것은 정밀도는 실수 자체를 표현할 때 유효한 의미를 가지고, 연산을 하게 되면 오차는 불가피함.
 - 자바에서 실수형 데이터타입 float과 double 중 어떤 쪽으로 형변환 되는가는 바로 정밀도에 달려 있음.
​
8.상수란 무엇이며 변수와의 차이는?
 - 상수는 변수와 다르게 항상 같은 수.
 - 보통 final이 변수 선언 앞에 붙고 / 선언된 변수 이름은 전체가 대문자로 이루어지며 / 합성어일 경우 _ 로
   연결함(뱀 표기법)
 - 변수의 경우에는 선언과 초기화 후에도 계속 값을 할당하는 것이 가능하지만, 상수는 초기화를 한 번 하면
   더이상 값을 할당할 수 없음.
 - ex. final int MAX_SIZE = 200;​
 
9.초기화란 무엇인가?
 - 변수를 선언한 다음 해당 변수에 처음을 값을 대입하는 것.
​
10.리터럴이란 무엇인가요?
 - 리터럴 상수는 값을 의미하는데, 변수와 마찬가지로 연산을 하려면 각 리터럴이 할당 받은 메모리에 들어가
   CPU를 거쳐야지만 연산을 할 수 있음.
 - 리터럴 뒤에 F/f, D/d, L/l 을 표시해주면, 자동형변환을 막아 원래의 데이터타입으로 표시할 수 있음.
​
11.아래의 내용이 에러가 나는 이유와 수정방법은?
System.out.println(3147483647 + 3147483648);
  - 두 리터럴은 정수형이므로 자바에서는 자동으로 int로 형변환하는데, 문제는 두 리터럴이 int의 표현 범위를
    넘어가기 때문에 에러가 나게 됨.
  - 따라서 두 리터럴 뒤에 정수형의 더 큰 데이터타입인 long형 표시(L 혹은 l)해주면 에러를 수정할 수 있음
​
12.자동 형변환과 명시적 형변환에 대하여 설명하시오.
  - 자바에서는 같은 데이터타입끼리 연산이 가능. 만약 서로 다른 데이터타입끼리의 연산이 있다면 자바는
    소수점의 손실이 없고 + 더 큰 크기의 데이터타입으로 형을 바꿔줌.
    byte → short, char → int → long → float → double 방향으로 자동 형변환됨.
    (ex. long형과 float형 리터럴이 있다면? float형으로 형변환됨. long형은 8바이트, float형은 4바이트지만
     float형의 표현 범위가 더 넓고, 소수점을 유지하는 방향이기 때문에 float형으로 바뀜)
​
13.아래의 에러가 나는 이유를 설명하고 수정하시오.
   	int a = 3;
   	int b = 4;
   	
   	double result = a / b;
   	
   	System.out.println(result);
​
  - 에러는 나지 않지만 원하는 결과처럼 소수점은 나오지 않고 정수까지만 표현됨.
    a/b는 int와 int 연산이기 때문에 이미 연산 결과가 정수가 되고, 그것을 실수형으로 표현만 해주게 됨.
    따라서 원하는 결과처럼 소수점까지 표현하고 싶다면, 연산이 완료되기 전에 형 변환을 해주어야 함.
    두 변수 중 하나만 double형으로 바꿔도 double / int 연산 = double형이 되므로, 둘 중 하나만 바꿔주도록
    함.
​
14.이스퀘이프 시퀀스의 종료를 나열하고 기능을 설명하시오.
 - \b : 시퀀스가 붙은 지점부터 백스페이스 한 칸 작동​
 - \n : 시퀀스가 붙은 지점부터 다음 줄로 이동​
 - \r : 시퀀스가 붙은 지점부터 처음으로 이동​​ + 첫 번째 값 대체 + 개행
 - \t : 시퀀스가 붙은 지점부터 탭 한 칸 작동​
 - \\ : 자바에서 정한 기능이 아닌 문자 자체로 \를 출력하고자 할 때​
 - \' : 자바에서 정한 기능이 아닌 문자 자체로 '를 출력하고자 할 때​​
 - \" : 자바에서 정한 기능이 아닌 문자 자체로 "를 출력하고자 할 때​​
​
15.아래의 출력결과를 확인하고, 130이 나오는 이유를 설명하시오.
System.out.println('A' + 'A')​
  - char + char 연산이므로 아스키 코드 표에서 A의 번호(65)가 문자 A 대신 들어가는데, 이것이 + 연산으로
   연결되면서 65 + 65가 되어 결과값이 AA가 아닌 130이 나오게 됨
​​